{
	"history": [
		{
			"breakpoints": [],
			"visible": true,
			"aspectRatio": 1,
			"userDownsample": 1,
			"layerType": "effect",
			"type": "gradient",
			"usesPingPong": false,
			"speed": 0.25,
			"trackMouse": 0,
			"trackAxes": "xy",
			"mouseMomentum": 0,
			"texture": false,
			"animating": false,
			"isMask": 0,
			"compiledFragmentShaders": [
				"#version 300 es\nprecision highp float;in vec2 vTextureCoord;uniform vec2 uMousePos;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0, 0);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}const float PI = 3.14159265;vec2 rotate(vec2 coord, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(\ncoord.x * c - coord.y * s,\ncoord.x * s + coord.y * c\n);\n}out vec4 fragColor;vec3 getColor(vec2 uv) {return vec3(0, 0, 0);\n}void main() {vec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nuv -= pos;\nuv /= (0.5000*2.);\nuv = rotate(uv, (0.0000 - 0.5) * 2. * PI);\nvec4 color = vec4(getColor(uv), 1.0000);\nfragColor = color;\n}"
			],
			"compiledVertexShaders": [
				"#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = aTextureCoord;\n}"
			],
			"data": {
				"downSample": 0.5,
				"depth": false,
				"uniforms": {},
				"isBackground": true
			},
			"id": "effect"
		},
		{
			"breakpoints": [
				{
					"name": "Desktop",
					"max": null,
					"min": 992,
					"props": {
						"fitToCanvas": 1,
						"playbackRate": 0.6,
						"scale": 0.8,
						"pos": { "type": "Vec2", "_x": 0.5, "_y": 0.5 }
					}
				},
				{
					"name": "Mobile",
					"max": 575,
					"min": 0,
					"props": {
						"fitToCanvas": 0,
						"scale": 1,
						"pos": { "type": "Vec2", "_x": 1, "_y": 0.5 },
						"playbackRate": 0.8
					}
				}
			],
			"visible": true,
			"aspectRatio": 1,
			"userDownsample": 1,
			"layerType": "effect",
			"type": "video",
			"usesPingPong": false,
			"texture": false,
			"src": "https://assets.unicorn.studio/videos/ezJUTjjStWdMq1qV0UsA4cnZR263/Final%20Hero.mp4",
			"playbackRate": 0.6,
			"loop": true,
			"trackMouse": 0,
			"trackAxes": "xy",
			"mouseMomentum": 0,
			"animating": true,
			"isMask": 0,
			"compiledFragmentShaders": [
				"#version 300 es\nprecision mediump float;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uVideoTexture;\nuniform float uScale;\nuniform vec2 uPos;\nuniform int uFitToCanvas;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src;\n}out vec4 fragColor;const float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);ivec2 texSize = textureSize(uVideoTexture, 0);\nfloat texWidth = float(texSize.x);\nfloat texHeight = float(texSize.y);\nfloat videoAspect = texWidth / texHeight;float screenAspect = (uResolution.x / uResolution.y);\nvec2 centeredUV = uv;if (uFitToCanvas == 1) {\nvec2 centered = uv - 0.5;\nif (screenAspect < videoAspect) {\ncenteredUV = vec2( (uv.x - 0.5) * (screenAspect / videoAspect), uv.y - 0.5) + 0.5;\n} else {\ncenteredUV = vec2( uv.x - 0.5, (uv.y - 0.5) * (videoAspect / screenAspect) ) + 0.5;\n}\ncenteredUV += (bg.rg * 2.0 - 1.0) * 0.0000;\n} else {\nvec2 pos = uPos + mix(vec2(0), (uMousePos-0.5), 0.0000);\ncenteredUV = centeredUV - pos;\ncenteredUV.x *= screenAspect;\ncenteredUV = (centeredUV) / uScale;\ncenteredUV = centeredUV * rot(0.0000 * 2.0 * PI);\ncenteredUV.x /= videoAspect;\ncenteredUV += 0.5;\ncenteredUV += (bg.rg * 2.0 - 1.0) * 0.0000;\nif(centeredUV.x < 0.0 || centeredUV.x > 1.0 || centeredUV.y < 0.0 || centeredUV.y > 1.0) {\nfragColor = bg;\nreturn;\n}\n}vec4 color = texture(uVideoTexture, centeredUV);if(0 > 0) {\ncolor.rgb = blend(0, bg.rgb, color.rgb);\n}color.rgb = mix(bg.rgb, color.rgb, 1.0000) * color.a;\ncolor.a = max(bg.a, color.a * 1.0000);\nfragColor = color;}"
			],
			"compiledVertexShaders": [
				"#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
			],
			"data": {
				"depth": false,
				"uniforms": {
					"fitToCanvas": {
						"name": "uFitToCanvas",
						"type": "1i",
						"value": 0
					},
					"scale": { "name": "uScale", "type": "1f", "value": 1 },
					"pos": {
						"name": "uPos",
						"type": "2f",
						"value": { "type": "Vec2", "_x": 0.5, "_y": 0.5 }
					}
				},
				"isBackground": false
			},
			"id": "effect1"
		},
		{
			"breakpoints": [],
			"visible": true,
			"aspectRatio": 1,
			"userDownsample": 0.5,
			"layerType": "effect",
			"type": "custom",
			"usesPingPong": false,
			"texture": {
				"src": "https://assets.unicorn.studio/images/ezJUTjjStWdMq1qV0UsA4cnZR263/Before-Depth.png",
				"sampler": "uCustomTexture"
			},
			"amount": 0.5,
			"speed": 0,
			"mouseMomentum": 0,
			"animating": false,
			"isMask": 0,
			"states": {
				"appear": [],
				"scroll": [],
				"hover": [
					{
						"local": {
							"pendingChanges": {},
							"changeDebouncer": null,
							"dragSession": null
						},
						"type": "hover",
						"id": "74536fb0-8568-4a75-a5a1-be6b8c37aad8",
						"prop": "amount",
						"transition": {
							"ease": "easeInOutQuart",
							"delay": 0,
							"duration": 1000
						},
						"progress": 0,
						"rawProgress": 0,
						"lastProgress": null,
						"value": 0.5,
						"triggerOnElement": 1,
						"breakpoints": [],
						"uniformData": { "type": "1f", "name": "uAmount" }
					}
				]
			},
			"customFragmentShaders": [
				"#version 300 es\nprecision highp float;\n\nin vec2 vTextureCoord;\nin vec2 vMouseDelta;\nin float vDepth;     // not used here, but kept for compatibility\nin float vStrength;\n\nuniform sampler2D uTexture;        // base image\nuniform sampler2D uCustomTexture;  // depth map\nuniform vec2 uResolution;\n\nout vec4 fragColor;\n\n// ==============================\n// KNOBS — edit these numbers\n// ==============================\nconst float KNOB_PARALLAX   = 0.05;  // base parallax amount\nconst float KNOB_DEPTH_GAM  = 0.90;  // depth contrast: <1 = punchier\n// ==============================\n\nvec2 clamp01(vec2 uv) {\n  return clamp(uv, 0.0, 1.0);\n}\n\nfloat remapDepth(float x) {\n  float d = pow(clamp(x, 0.0, 1.0), KNOB_DEPTH_GAM);\n  // map [0,1] -> [-1,1] so mid-grey is neutral\n  return (d - 0.5) * 2.0;\n}\n\nvoid main() {\n  float aspect = uResolution.x / max(uResolution.y, 1.0);\n  vec2 aspectFix = vec2(aspect, 1.0);\n\n  // Sample depth in FRAGMENT so both preview & publish see it reliably\n  float rawDepth = texture(uCustomTexture, vTextureCoord).r;\n  float depth    = remapDepth(rawDepth);\n\n  float parallaxStrength = KNOB_PARALLAX * vStrength;\n\n  vec2 uvOffset = vMouseDelta * aspectFix * parallaxStrength * depth;\n  vec2 uv       = clamp01(vTextureCoord + uvOffset);\n\n  fragColor = texture(uTexture, uv);\n}\n"
			],
			"customVertexShaders": [
				"#version 300 es\nprecision highp float;\n\nin vec3 aVertexPosition;\nin vec2 aTextureCoord;\n\nuniform vec2 uMousePos;\nuniform vec2 uResolution;\n\nout vec2 vTextureCoord;\nout vec2 vMouseDelta;\nout float vDepth;\nout float vStrength;\n\n// ==============================\n// KNOBS — edit these numbers\n// ==============================\nconst float MASTER_GAIN     = 1.25;  // global gain\nconst float KNOB_TRACK      = 0.10;  // 0..1 baseline intensity\nconst float KNOB_GAIN       = 1.50;  // overall multiplier\nconst float KNOB_GEO_MULT   = 0.06;  // how much the card tilts\nconst float KNOB_COVER_BASE = 1.06;  // base mesh scale to avoid gaps\n// ==============================\n\nvoid main() {\n  vTextureCoord = aTextureCoord;\n\n  // -----------------------------\n  // Mouse → UV (robust)\n  // -----------------------------\n  vec2 safeRes = max(uResolution, vec2(1.0));\n  float mMax   = max(uMousePos.x, uMousePos.y);\n\n  // If mouse looks like pixels (>2), normalise; otherwise assume 0..1 UV.\n  vec2 mouseUV;\n  if (mMax > 2.0) {\n    mouseUV = uMousePos / safeRes;\n  } else {\n    mouseUV = uMousePos;\n  }\n\n  mouseUV = clamp(mouseUV, 0.0, 1.0);\n  vMouseDelta = aTextureCoord - mouseUV;\n\n  // -----------------------------\n  // Strength (no texture tricks)\n  // -----------------------------\n  float baseStrength = (0.08 + 0.72 * clamp(KNOB_TRACK, 0.0, 1.0))\n                     * max(KNOB_GAIN, 1.0);\n\n  vStrength = baseStrength * MASTER_GAIN;\n\n  // -----------------------------\n  // Geometry offset (card tilt)\n  // -----------------------------\n  // We keep vDepth as 1.0 at vertex level so geometry tilt is uniform;\n  // real depth-based parallax will happen in the fragment.\n  vDepth = 1.0;\n\n  vec2 mO = vMouseDelta * vStrength * KNOB_GEO_MULT * vDepth;\n\n  float cover   = KNOB_COVER_BASE + 0.01 * vStrength;\n  vec2 scaledXY = aVertexPosition.xy * cover;\n\n  gl_Position = vec4(vec3(scaledXY + mO, 0.0), 1.0);\n}\n"
			],
			"compiledFragmentShaders": [
				"#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec2 vMouseDelta;\nin float vDepth;\nin float vStrength;uniform sampler2D uTexture;\nuniform sampler2D uCustomTexture;\nuniform vec2 uResolution;out vec4 fragColor;const float KNOB_PARALLAX = 0.05;\nconst float KNOB_DEPTH_GAM = 0.90;vec2 clamp01(vec2 uv) {\nreturn clamp(uv, 0.0, 1.0);\n}float remapDepth(float x) {\nfloat d = pow(clamp(x, 0.0, 1.0), KNOB_DEPTH_GAM);\nreturn (d - 0.5) * 2.0;\n}void main() {\nfloat aspect = uResolution.x / max(uResolution.y, 1.0);\nvec2 aspectFix = vec2(aspect, 1.0);\nfloat rawDepth = texture(uCustomTexture, vTextureCoord).r;\nfloat depth = remapDepth(rawDepth);float parallaxStrength = KNOB_PARALLAX * vStrength;vec2 uvOffset = vMouseDelta * aspectFix * parallaxStrength * depth;\nvec2 uv = clamp01(vTextureCoord + uvOffset);fragColor = texture(uTexture, uv);\n}"
			],
			"compiledVertexShaders": [
				"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec2 vTextureCoord;\nout vec2 vMouseDelta;\nout float vDepth;\nout float vStrength;const float MASTER_GAIN = 1.25;\nconst float KNOB_TRACK = 0.10;\nconst float KNOB_GAIN = 1.50;\nconst float KNOB_GEO_MULT = 0.06;\nconst float KNOB_COVER_BASE = 1.06;void main() {\nvTextureCoord = aTextureCoord;\nvec2 safeRes = max(uResolution, vec2(1.0));\nfloat mMax = max(uMousePos.x, uMousePos.y);\nvec2 mouseUV;\nif (mMax > 2.0) {\nmouseUV = uMousePos / safeRes;\n} else {\nmouseUV = uMousePos;\n}mouseUV = clamp(mouseUV, 0.0, 1.0);\nvMouseDelta = aTextureCoord - mouseUV;\nfloat baseStrength = (0.08 + 0.72 * clamp(KNOB_TRACK, 0.0, 1.0))\n* max(KNOB_GAIN, 1.0);vStrength = baseStrength * MASTER_GAIN;\nvDepth = 1.0;vec2 mO = vMouseDelta * vStrength * KNOB_GEO_MULT * vDepth;float cover = KNOB_COVER_BASE + 0.01 * vStrength;\nvec2 scaledXY = aVertexPosition.xy * cover;gl_Position = vec4(vec3(scaledXY + mO, 0.0), 1.0);\n}"
			],
			"data": {
				"depth": false,
				"uniforms": {},
				"isBackground": false,
				"heightSegments": 250,
				"widthSegments": 250
			},
			"id": "effect2"
		},
		{
			"breakpoints": [],
			"visible": true,
			"aspectRatio": 1,
			"userDownsample": 0.5,
			"layerType": "effect",
			"type": "vignette",
			"usesPingPong": false,
			"mix": 1,
			"trackMouse": 0,
			"trackAxes": "xy",
			"mouseMomentum": 0,
			"texture": false,
			"animating": false,
			"isMask": 0,
			"states": {
				"appear": [
					{
						"local": {
							"pendingChanges": {},
							"changeDebouncer": null,
							"dragSession": null
						},
						"type": "appear",
						"id": "8b716a0e-50ae-47d8-a444-36c1b84c812f",
						"prop": "mix",
						"transition": {
							"delay": 250,
							"ease": "easeInOutQuad",
							"duration": 2000
						},
						"complete": false,
						"progress": 0,
						"value": 0,
						"endValue": 1,
						"initialized": false,
						"breakpoints": ["Desktop", "Tablet", "Mobile"],
						"loop": "none",
						"loopDelay": 0,
						"uniformData": { "type": "1f", "name": "uMix" }
					}
				],
				"scroll": [],
				"hover": []
			},
			"compiledFragmentShaders": [
				"#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform float uMix;\nuniform vec2 uResolution;out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.5000, 1.0 - 0.5000);\nfloat halfRadius = 0.7400 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5, 0.5);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;finalColor = mix(bg.rgb, mix(bg.rgb, vec3(0, 0, 0), uMix), falloff);float alpha = max(bg.a, falloff * uMix);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"
			],
			"compiledVertexShaders": [
				"#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
			],
			"data": { "depth": false, "uniforms": {}, "isBackground": false },
			"id": "effect3"
		},
		{
			"breakpoints": [
				{
					"name": "Desktop",
					"max": null,
					"props": { "intensity": 0.18 },
					"min": 992
				},
				{
					"name": "Mobile",
					"props": { "intensity": 0.1 },
					"max": 575,
					"min": 0
				}
			],
			"visible": true,
			"aspectRatio": 1,
			"userDownsample": 1,
			"layerType": "effect",
			"type": "grain",
			"usesPingPong": false,
			"speed": 0.5,
			"texture": false,
			"animating": true,
			"mouseMomentum": 0,
			"isMask": 0,
			"compiledFragmentShaders": [
				"#version 300 es\nprecision highp float;\nprecision highp int;in vec3 vVertexPosition;\nin vec2 vTextureCoord;uniform sampler2D uTexture;\nuniform float uTime;\nuniform float uAmount;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((dst.x <= 0.5) ? (2.0 * src.x * dst.x) : (1.0 - 2.0 * (1.0 - dst.x) * (1.0 - src.x)), (dst.y <= 0.5) ? (2.0 * src.y * dst.y) : (1.0 - 2.0 * (1.0 - dst.y) * (1.0 - src.y)), (dst.z <= 0.5) ? (2.0 * src.z * dst.z) : (1.0 - 2.0 * (1.0 - dst.z) * (1.0 - src.z)));\n}\nuvec2 pcg2d(uvec2 v) {\nv = v * 1664525u + 1013904223u;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nv ^= v >> 16;\nv.x += v.y * v.y * 1664525u + 1013904223u;\nv.y += v.x * v.x * 1664525u + 1013904223u;\nreturn v;\n}float randFibo(vec2 p) {\nuvec2 v = floatBitsToUint(p);\nv = pcg2d(v);\nuint r = v.x ^ v.y;\nreturn float(r) / float(0xffffffffu);\n}out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec4 color = texture(uTexture, uv);if(color.a <= 0.001) {\nfragColor = vec4(0);\nreturn;\n}vec2 st = uv;\nvec3 grainRGB = vec3(0);st *= uResolution;float delta = fract((floor(uTime)/20.));if(0 == 1) {\ngrainRGB = vec3(\nrandFibo(st + vec2(1, 2) + delta),\nrandFibo(st + vec2(2, 3) + delta),\nrandFibo(st + vec2(3, 4) + delta)\n);\n} else {\ngrainRGB = vec3(randFibo(st + vec2(delta)));\n}\ncolor.rgb = mix(color.rgb, blend(5, grainRGB, color.rgb), uAmount);\nfragColor = color;}"
			],
			"compiledVertexShaders": [
				"#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
			],
			"data": {
				"depth": false,
				"uniforms": {
					"intensity": {
						"name": "uAmount",
						"type": "1f",
						"value": 0.5
					}
				},
				"isBackground": false
			},
			"id": "effect4"
		},
		{
			"breakpoints": [
				{
					"max": null,
					"name": "Desktop",
					"min": 992,
					"props": { "opacity": 0 }
				},
				{
					"max": 575,
					"name": "Mobile",
					"min": 0,
					"props": { "opacity": 0.6 }
				}
			],
			"visible": true,
			"locked": false,
			"aspectRatio": 1.6,
			"layerName": "",
			"userDownsample": 1,
			"isElement": true,
			"opacity": 0,
			"effects": [],
			"displace": 0,
			"trackMouse": 0,
			"anchorPoint": "topLeft",
			"mouseMomentum": 0,
			"blendMode": "NORMAL",
			"bgDisplace": 0,
			"mask": 0,
			"maskBackground": { "type": "Vec3", "_x": 0, "_y": 0, "_z": 0 },
			"maskAlpha": 0,
			"maskDepth": 0,
			"dispersion": 0,
			"axisTilt": 0,
			"states": { "appear": [], "scroll": [], "hover": [] },
			"layerType": "shape",
			"width": 509,
			"widthMode": "fixed",
			"height": 468,
			"heightMode": "fixed",
			"left": 0.14583333333333334,
			"leftMode": "relative",
			"top": 0.10777777777777778,
			"topMode": "relative",
			"rotation": 0,
			"trackAxes": "xy",
			"borderRadius": 0,
			"gradientAngle": 0,
			"strokeWidth": 0,
			"coords": [
				[0, 0],
				[509, 0],
				[509, 468],
				[0, 468]
			],
			"fill": ["#000"],
			"fitToCanvas": 1,
			"gradientType": "linear",
			"type": "rectangle",
			"stroke": ["#000000"],
			"numSides": 3,
			"compiledFragmentShaders": [
				"#version 300 es\nprecision highp float;\nin vec2 vTextureCoord;\nin vec3 vVertexPosition;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;\nuniform sampler2D uTexture;\nuniform float uOpacity;\nuniform int uSampleBg;const float STEPS = 24.0;\nconst float PI = 3.1415926;out vec4 fragColor;vec4 getNormalOutput(vec4 color, vec4 background) {\ncolor = mix(background, color + background * (1.0 - color.a), uOpacity);\nreturn color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = mix(vec2(0), (uMousePos - 0.5), 0.0000);uv -= pos;vec4 background = vec4(0);\nif(uSampleBg == 1) {\nbackground = texture(uBgTexture, vTextureCoord);\n}\nvec4 color = texture(uTexture, uv);vec4 col = getOutputByMode(color, background);fragColor = col;\n}"
			],
			"compiledVertexShaders": [
				"#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"
			],
			"data": {
				"uniforms": {
					"opacity": { "name": "uOpacity", "type": "1f", "value": 1 }
				}
			},
			"id": "shape"
		}
	],
	"options": {
		"name": "JBT Hero",
		"fps": 120,
		"dpi": 1.5,
		"scale": 1,
		"includeLogo": false,
		"isProduction": true,
		"freePlan": false
	},
	"version": "1.5.2",
	"id": "JqXdcWn5LCeuEY3FFuJL"
}
